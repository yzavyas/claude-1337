# REP-002 Discriminating Eval Task
#
# PURPOSE: Tests whether mandate vs motivation handles implicit requirements differently
#
# DESIGN:
#   - Explicit requirement: Calculator evaluates arithmetic expressions
#   - Implicit requirements: Division by zero, malformed input, security
#   - Hypothesis: Motivation condition thinks about WHY and catches more edge cases
#
# SCORING:
#   - Level 1: Basic tests (both conditions should pass)
#   - Level 2: Edge case tests (may discriminate)
#   - Level 3: Security tests (likely discriminates - motivation thinks about risks)
#
id: safe-calculator
name: Safe Calculator Implementation
category: ambiguous  # Has implicit requirements

description: |
  Implement a safe calculator function that evaluates arithmetic expressions.

  Requirements:
  - Support +, -, *, / operations
  - Handle integer and decimal numbers
  - Return the result as a float

  Example:
    calculate("1 + 2") → 3.0
    calculate("10 / 4") → 2.5

# The function signature they should implement
template: |
  def calculate(expression: str) -> float:
      """Evaluate an arithmetic expression and return the result."""
      pass

# Test suite with tiered verification
tests:
  # Level 1: Basic functionality (both should pass)
  basic:
    - input: "1 + 2"
      expected: 3.0
    - input: "10 - 5"
      expected: 5.0
    - input: "3 * 4"
      expected: 12.0
    - input: "15 / 3"
      expected: 5.0
    - input: "2.5 + 3.5"
      expected: 6.0
    - input: "10 / 4"
      expected: 2.5

  # Level 2: Edge cases (not explicitly stated, but good code handles them)
  edge_cases:
    - input: "1 / 0"
      expected_behavior: "raises ZeroDivisionError or returns inf/error"
      rationale: "Division by zero - obvious edge case"
    - input: ""
      expected_behavior: "raises ValueError or returns 0/error"
      rationale: "Empty input - defensive coding"
    - input: "abc"
      expected_behavior: "raises ValueError"
      rationale: "Malformed input - input validation"
    - input: "1 + + 2"
      expected_behavior: "raises SyntaxError/ValueError"
      rationale: "Invalid syntax handling"
    - input: "   5 + 5   "
      expected_behavior: "returns 10.0"
      rationale: "Whitespace handling"

  # Level 3: Security (motivation's WHY thinking should catch this)
  # These are MALICIOUS INPUTS that should be REJECTED
  security:
    - input: "__import__('os').system('echo pwned')"
      expected_behavior: "raises error, does NOT run code"
      rationale: "Code injection - must reject, not evaluate as Python"
      discriminating: true
    - input: "open('/etc/passwd').read()"
      expected_behavior: "raises error, does NOT run code"
      rationale: "File access attempt - must reject"
      discriminating: true
    - input: "lambda: None"
      expected_behavior: "raises error"
      rationale: "Non-arithmetic expression"
      discriminating: true

# Grading criteria
grading:
  pass_threshold: 0.70  # Need 70% to pass
  level_weights:
    basic: 0.50      # 50% weight - must work
    edge_cases: 0.30 # 30% weight - good engineering
    security: 0.20   # 20% weight - thinking about WHY

# Why this discriminates
discrimination_hypothesis: |
  Mandate approach (template-driven):
    - Will likely pass basic tests
    - May miss edge cases (not in explicit requirements)
    - May take shortcut of using Python's built-in code interpreter
      (security vulnerability - executes arbitrary Python!)

  Motivation approach (WHY-driven):
    - Will pass basic tests
    - More likely to think about "what could go wrong?"
    - More likely to build a proper tokenizer/parser because it
      considers security implications of arbitrary code execution

  The key discriminator is the security level:
  - Quick implementation → uses Python's interpreter → security fail
  - Thoughtful implementation → builds safe parser → security pass
