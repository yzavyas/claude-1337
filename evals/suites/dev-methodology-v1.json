{
  "name": "dev-methodology-v1",
  "description": "Development methodology comparison test corpus. Tasks stratified by category and difficulty to measure where different methodologies excel.",
  "version": "1.0.0",
  "runs_per_case": 5,
  "categories": [
    {
      "name": "trivial_fix",
      "description": "Simple fixes where methodology overhead should hurt",
      "difficulty": "trivial",
      "tasks": [
        {
          "id": "trivial-01",
          "prompt": "Fix the typo in this error message. The file src/errors.ts has 'Authetication failed' which should be 'Authentication failed'.",
          "setup": {
            "files": {
              "src/errors.ts": "export const AUTH_ERROR = 'Authetication failed';\nexport const NOT_FOUND = 'Resource not found';\n"
            }
          },
          "verification": {
            "type": "file_contains",
            "file": "src/errors.ts",
            "contains": "Authentication failed",
            "not_contains": "Authetication"
          },
          "expected_behaviors": ["minimal_changes", "preserves_other_code"],
          "rationale": "Trivial fix - methodology overhead should slow this down"
        },
        {
          "id": "trivial-02",
          "prompt": "The function getUserById is missing a return type. Add ': User | null' as the return type.",
          "setup": {
            "files": {
              "src/users.ts": "interface User { id: string; name: string; }\n\nexport function getUserById(id: string) {\n  // implementation\n  return null;\n}\n"
            }
          },
          "verification": {
            "type": "regex_match",
            "file": "src/users.ts",
            "pattern": "getUserById\\(id: string\\):\\s*User\\s*\\|\\s*null"
          },
          "expected_behaviors": ["type_annotation_only"],
          "rationale": "Simple type fix - should be quick"
        }
      ]
    },
    {
      "name": "simple_feature",
      "description": "Small features that benefit from some planning",
      "difficulty": "easy",
      "tasks": [
        {
          "id": "simple-01",
          "prompt": "Add a /health endpoint that returns JSON {\"status\": \"ok\", \"timestamp\": <current ISO timestamp>}. Use Express.js patterns.",
          "setup": {
            "files": {
              "src/app.ts": "import express from 'express';\n\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.json({ message: 'Hello World' });\n});\n\nexport default app;\n",
              "package.json": "{ \"dependencies\": { \"express\": \"^4.18.0\" } }"
            }
          },
          "verification": {
            "type": "test_suite",
            "test_file": "tests/health.test.ts",
            "test_content": "import request from 'supertest';\nimport app from '../src/app';\n\ndescribe('GET /health', () => {\n  it('returns status ok', async () => {\n    const res = await request(app).get('/health');\n    expect(res.status).toBe(200);\n    expect(res.body.status).toBe('ok');\n  });\n\n  it('includes timestamp', async () => {\n    const res = await request(app).get('/health');\n    expect(res.body.timestamp).toBeDefined();\n    expect(new Date(res.body.timestamp).getTime()).not.toBeNaN();\n  });\n});\n"
          },
          "expected_behaviors": ["adds_route", "returns_json", "includes_timestamp"],
          "rationale": "Simple feature - some planning helps but not much"
        },
        {
          "id": "simple-02",
          "prompt": "Add input validation to the createUser function. It should throw an Error if email is empty or doesn't contain '@', or if name is less than 2 characters.",
          "setup": {
            "files": {
              "src/users.ts": "interface CreateUserInput {\n  email: string;\n  name: string;\n}\n\nexport function createUser(input: CreateUserInput) {\n  return {\n    id: Math.random().toString(36),\n    ...input,\n    createdAt: new Date()\n  };\n}\n"
            }
          },
          "verification": {
            "type": "test_suite",
            "test_file": "tests/users.test.ts",
            "test_content": "import { createUser } from '../src/users';\n\ndescribe('createUser validation', () => {\n  it('throws on empty email', () => {\n    expect(() => createUser({ email: '', name: 'John' })).toThrow();\n  });\n\n  it('throws on email without @', () => {\n    expect(() => createUser({ email: 'invalid', name: 'John' })).toThrow();\n  });\n\n  it('throws on short name', () => {\n    expect(() => createUser({ email: 'test@test.com', name: 'J' })).toThrow();\n  });\n\n  it('succeeds with valid input', () => {\n    const user = createUser({ email: 'test@test.com', name: 'John' });\n    expect(user.email).toBe('test@test.com');\n    expect(user.name).toBe('John');\n    expect(user.id).toBeDefined();\n  });\n});\n"
          },
          "expected_behaviors": ["validates_email", "validates_name", "throws_errors"],
          "rationale": "Validation logic - needs to think about edge cases"
        }
      ]
    },
    {
      "name": "multi_step_feature",
      "description": "Features requiring multiple files and coordination",
      "difficulty": "medium",
      "tasks": [
        {
          "id": "multi-01",
          "prompt": "Implement rate limiting middleware. Limit to 100 requests per minute per IP address. Return 429 with JSON {\"error\": \"rate_limit_exceeded\", \"retry_after\": <seconds>} when exceeded. Use in-memory storage (Map).",
          "setup": {
            "files": {
              "src/app.ts": "import express from 'express';\n\nconst app = express();\n\napp.get('/api/data', (req, res) => {\n  res.json({ data: 'secret' });\n});\n\nexport default app;\n",
              "src/middleware/index.ts": "// Middleware exports\n"
            }
          },
          "verification": {
            "type": "test_suite",
            "test_file": "tests/rate-limit.test.ts",
            "test_content": "import request from 'supertest';\nimport app from '../src/app';\n\ndescribe('Rate limiting', () => {\n  it('allows requests under limit', async () => {\n    const res = await request(app).get('/api/data');\n    expect(res.status).toBe(200);\n  });\n\n  it('blocks after 100 requests', async () => {\n    // Make 100 requests first\n    for (let i = 0; i < 100; i++) {\n      await request(app).get('/api/data').set('X-Forwarded-For', '1.2.3.4');\n    }\n    // 101st should be blocked\n    const res = await request(app).get('/api/data').set('X-Forwarded-For', '1.2.3.4');\n    expect(res.status).toBe(429);\n    expect(res.body.error).toBe('rate_limit_exceeded');\n    expect(res.body.retry_after).toBeDefined();\n  });\n\n  it('tracks IPs separately', async () => {\n    // Different IP should work\n    const res = await request(app).get('/api/data').set('X-Forwarded-For', '5.6.7.8');\n    expect(res.status).toBe(200);\n  });\n});\n"
          },
          "expected_behaviors": ["creates_middleware", "tracks_per_ip", "returns_429", "includes_retry_after"],
          "rationale": "Multi-step feature - needs planning for middleware integration"
        },
        {
          "id": "multi-02",
          "prompt": "Add pagination to the listUsers endpoint. Support ?page=N&limit=M query params. Default page=1, limit=10. Return {\"data\": [...], \"pagination\": {\"page\": N, \"limit\": M, \"total\": T, \"totalPages\": P}}.",
          "setup": {
            "files": {
              "src/app.ts": "import express from 'express';\n\nconst app = express();\n\n// Mock database\nconst users = Array.from({ length: 50 }, (_, i) => ({\n  id: String(i + 1),\n  name: `User ${i + 1}`,\n  email: `user${i + 1}@test.com`\n}));\n\napp.get('/api/users', (req, res) => {\n  res.json(users);\n});\n\nexport default app;\n"
            }
          },
          "verification": {
            "type": "test_suite",
            "test_file": "tests/pagination.test.ts",
            "test_content": "import request from 'supertest';\nimport app from '../src/app';\n\ndescribe('User pagination', () => {\n  it('returns default page with 10 items', async () => {\n    const res = await request(app).get('/api/users');\n    expect(res.status).toBe(200);\n    expect(res.body.data.length).toBe(10);\n    expect(res.body.pagination.page).toBe(1);\n    expect(res.body.pagination.limit).toBe(10);\n    expect(res.body.pagination.total).toBe(50);\n    expect(res.body.pagination.totalPages).toBe(5);\n  });\n\n  it('returns requested page', async () => {\n    const res = await request(app).get('/api/users?page=2');\n    expect(res.body.data[0].id).toBe('11');\n    expect(res.body.pagination.page).toBe(2);\n  });\n\n  it('respects custom limit', async () => {\n    const res = await request(app).get('/api/users?limit=5');\n    expect(res.body.data.length).toBe(5);\n    expect(res.body.pagination.totalPages).toBe(10);\n  });\n\n  it('handles last page correctly', async () => {\n    const res = await request(app).get('/api/users?page=5');\n    expect(res.body.data.length).toBe(10);\n    expect(res.body.data[0].id).toBe('41');\n  });\n});\n"
          },
          "expected_behaviors": ["parses_query_params", "calculates_pagination", "returns_correct_slice"],
          "rationale": "Pagination requires thinking about edge cases (last page, total calculation)"
        }
      ]
    },
    {
      "name": "architecture_task",
      "description": "Tasks requiring structural thinking",
      "difficulty": "hard",
      "tasks": [
        {
          "id": "arch-01",
          "prompt": "Refactor the monolithic userService into separate concerns: UserRepository (data access), UserValidator (validation logic), and UserService (business logic orchestration). Maintain the same public API from UserService.",
          "setup": {
            "files": {
              "src/services/userService.ts": "interface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\nconst users: Map<string, User> = new Map();\n\nexport class UserService {\n  createUser(email: string, name: string): User {\n    if (!email || !email.includes('@')) {\n      throw new Error('Invalid email');\n    }\n    if (!name || name.length < 2) {\n      throw new Error('Name too short');\n    }\n    const id = Math.random().toString(36).slice(2);\n    const user = { id, email, name };\n    users.set(id, user);\n    return user;\n  }\n\n  getUser(id: string): User | null {\n    return users.get(id) || null;\n  }\n\n  updateUser(id: string, updates: Partial<User>): User {\n    const user = users.get(id);\n    if (!user) throw new Error('User not found');\n    if (updates.email && !updates.email.includes('@')) {\n      throw new Error('Invalid email');\n    }\n    const updated = { ...user, ...updates };\n    users.set(id, updated);\n    return updated;\n  }\n\n  deleteUser(id: string): void {\n    if (!users.has(id)) throw new Error('User not found');\n    users.delete(id);\n  }\n}\n"
            }
          },
          "verification": {
            "type": "test_suite",
            "test_file": "tests/user-service.test.ts",
            "test_content": "import { UserService } from '../src/services/userService';\n\ndescribe('UserService (refactored)', () => {\n  let service: UserService;\n\n  beforeEach(() => {\n    service = new UserService();\n  });\n\n  describe('createUser', () => {\n    it('creates user with valid input', () => {\n      const user = service.createUser('test@test.com', 'John');\n      expect(user.email).toBe('test@test.com');\n      expect(user.name).toBe('John');\n      expect(user.id).toBeDefined();\n    });\n\n    it('throws on invalid email', () => {\n      expect(() => service.createUser('invalid', 'John')).toThrow();\n    });\n\n    it('throws on short name', () => {\n      expect(() => service.createUser('test@test.com', 'J')).toThrow();\n    });\n  });\n\n  describe('getUser', () => {\n    it('returns created user', () => {\n      const created = service.createUser('test@test.com', 'John');\n      const found = service.getUser(created.id);\n      expect(found).toEqual(created);\n    });\n\n    it('returns null for unknown id', () => {\n      expect(service.getUser('unknown')).toBeNull();\n    });\n  });\n\n  describe('updateUser', () => {\n    it('updates user fields', () => {\n      const user = service.createUser('test@test.com', 'John');\n      const updated = service.updateUser(user.id, { name: 'Jane' });\n      expect(updated.name).toBe('Jane');\n    });\n\n    it('throws on invalid email update', () => {\n      const user = service.createUser('test@test.com', 'John');\n      expect(() => service.updateUser(user.id, { email: 'invalid' })).toThrow();\n    });\n  });\n\n  describe('deleteUser', () => {\n    it('deletes existing user', () => {\n      const user = service.createUser('test@test.com', 'John');\n      service.deleteUser(user.id);\n      expect(service.getUser(user.id)).toBeNull();\n    });\n\n    it('throws on unknown user', () => {\n      expect(() => service.deleteUser('unknown')).toThrow();\n    });\n  });\n});\n"
          },
          "expected_behaviors": ["separates_concerns", "maintains_api", "creates_repository", "creates_validator"],
          "rationale": "Refactoring requires understanding current structure and planning new one"
        }
      ]
    },
    {
      "name": "ambiguous_requirement",
      "description": "Tasks with unclear requirements that benefit from clarification",
      "difficulty": "medium",
      "tasks": [
        {
          "id": "ambig-01",
          "prompt": "Make the API faster.",
          "setup": {
            "files": {
              "src/app.ts": "import express from 'express';\n\nconst app = express();\n\n// Simulated slow database\nconst getUsers = async () => {\n  await new Promise(r => setTimeout(r, 100));\n  return Array.from({ length: 1000 }, (_, i) => ({ id: i, name: `User ${i}` }));\n};\n\napp.get('/api/users', async (req, res) => {\n  const users = await getUsers();\n  const users2 = await getUsers(); // Redundant call\n  res.json(users);\n});\n\napp.get('/api/users/:id', async (req, res) => {\n  const users = await getUsers();\n  const user = users.find(u => u.id === parseInt(req.params.id));\n  res.json(user || null);\n});\n\nexport default app;\n"
            }
          },
          "verification": {
            "type": "custom",
            "validator": "performance_improvement",
            "criteria": {
              "removes_redundant_call": true,
              "adds_caching_or_optimization": true,
              "maintains_functionality": true
            }
          },
          "expected_behaviors": ["identifies_problems", "proposes_solutions", "asks_clarifying_questions"],
          "rationale": "Ambiguous - methodologies should help clarify what 'faster' means"
        }
      ]
    },
    {
      "name": "integration_task",
      "description": "External API integration with error handling",
      "difficulty": "hard",
      "tasks": [
        {
          "id": "integ-01",
          "prompt": "Add Stripe payment integration. Create a POST /api/checkout endpoint that accepts {amount: number, currency: string, token: string} and creates a Stripe charge. Return {success: true, chargeId: string} on success, or {success: false, error: string} on failure. Handle network errors gracefully.",
          "setup": {
            "files": {
              "src/app.ts": "import express from 'express';\n\nconst app = express();\napp.use(express.json());\n\napp.get('/api/products', (req, res) => {\n  res.json([{ id: 1, name: 'Widget', price: 999 }]);\n});\n\nexport default app;\n",
              "package.json": "{ \"dependencies\": { \"express\": \"^4.18.0\", \"stripe\": \"^14.0.0\" } }",
              ".env.example": "STRIPE_SECRET_KEY=sk_test_..."
            }
          },
          "verification": {
            "type": "test_suite",
            "test_file": "tests/checkout.test.ts",
            "test_content": "import request from 'supertest';\nimport app from '../src/app';\n\n// Mock Stripe\njest.mock('stripe', () => {\n  return jest.fn().mockImplementation(() => ({\n    charges: {\n      create: jest.fn().mockImplementation(({ amount }) => {\n        if (amount <= 0) throw new Error('Invalid amount');\n        return Promise.resolve({ id: 'ch_test_123' });\n      })\n    }\n  }));\n});\n\ndescribe('POST /api/checkout', () => {\n  it('creates charge with valid input', async () => {\n    const res = await request(app)\n      .post('/api/checkout')\n      .send({ amount: 999, currency: 'usd', token: 'tok_test' });\n    expect(res.status).toBe(200);\n    expect(res.body.success).toBe(true);\n    expect(res.body.chargeId).toBeDefined();\n  });\n\n  it('returns error for invalid amount', async () => {\n    const res = await request(app)\n      .post('/api/checkout')\n      .send({ amount: 0, currency: 'usd', token: 'tok_test' });\n    expect(res.body.success).toBe(false);\n    expect(res.body.error).toBeDefined();\n  });\n\n  it('handles missing fields', async () => {\n    const res = await request(app)\n      .post('/api/checkout')\n      .send({ amount: 999 });\n    expect(res.body.success).toBe(false);\n  });\n});\n"
          },
          "expected_behaviors": ["creates_endpoint", "validates_input", "handles_errors", "uses_env_config"],
          "rationale": "Integration task - needs careful error handling planning"
        }
      ]
    }
  ],
  "global_negative_cases": [
    {
      "id": "neg-01",
      "prompt": "Write me a haiku about programming",
      "expectation": "should_not_apply_methodology",
      "rationale": "Creative task - no methodology should activate"
    },
    {
      "id": "neg-02",
      "prompt": "What is the capital of France?",
      "expectation": "should_not_apply_methodology",
      "rationale": "Knowledge question - no development methodology needed"
    }
  ]
}
