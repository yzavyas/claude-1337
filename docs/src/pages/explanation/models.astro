---
import Base from '../../layouts/Base.astro';
---

<Base title="models" description="understanding how claude models work">
  <p><a href="/claude-1337/explanation/">&larr; explanation</a></p>

  <h1>models</h1>

  <p class="dimmed-intro">understanding how claude models work in claude code</p>

  <h2>what is a model?</h2>

  <p>think of a model like different versions of claude with different capabilities. it's like having a team where:</p>

  <ul>
    <li><strong>opus</strong> is the senior architect — best at complex reasoning, planning, and difficult problems. slow but thorough.</li>
    <li><strong>sonnet</strong> is the experienced developer — balanced between speed and quality. handles most tasks well.</li>
    <li><strong>haiku</strong> is the junior developer — fast at simple, repetitive tasks. uses less resources.</li>
  </ul>

  <p>each model is trained on the same data but with different "brain sizes" (parameters). larger models can hold more patterns and make more nuanced decisions.</p>

  <h2>how claude code uses models</h2>

  <p>claude code defaults to sonnet for most work. but you can specify which model to use for specific tasks:</p>

  <pre><code># use opus for complex planning
claude --model opus "design the architecture for..."

# use haiku for simple repetitive tasks
claude --model haiku "run tests"</code></pre>

  <h3>when agents spawn sub-agents</h3>

  <p>agents can spawn sub-agents with different models. think of it like delegating:</p>

  <pre><code>Main agent (sonnet):
  ├─ Complex analysis → spawn opus agent
  ├─ Simple file search → spawn haiku agent
  └─ Code review → spawn sonnet agent</code></pre>

  <p>this is what the Task tool does when you see <code>model: "haiku"</code> in tool parameters.</p>

  <h2>model selection strategy</h2>

  <table>
    <thead>
      <tr>
        <th>task type</th>
        <th>recommended model</th>
        <th>why</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>architecture design, complex planning</td>
        <td>opus</td>
        <td>needs deep reasoning, multi-step planning</td>
      </tr>
      <tr>
        <td>code generation, refactoring, debugging</td>
        <td>sonnet</td>
        <td>balanced speed and quality</td>
      </tr>
      <tr>
        <td>file search, simple edits, test runs</td>
        <td>haiku</td>
        <td>fast, cost-effective, sufficient capability</td>
      </tr>
      <tr>
        <td>code review, explanation, research</td>
        <td>sonnet or opus</td>
        <td>needs nuance and context understanding</td>
      </tr>
    </tbody>
  </table>

  <h2>cost vs capability tradeoff</h2>

  <p>models have different costs (in both time and tokens):</p>

  <ul>
    <li><strong>opus</strong> — slowest, most expensive, highest quality</li>
    <li><strong>sonnet</strong> — balanced middle ground (default for good reason)</li>
    <li><strong>haiku</strong> — fastest, cheapest, good for simple tasks</li>
  </ul>

  <p>the key insight: don't use opus for everything just because it's "best". use the right tool for the job. a haiku agent searching files is faster and cheaper than opus doing the same task.</p>

  <h2>how models interact with skills</h2>

  <p>all models can use skills, but they evaluate skill relevance differently:</p>

  <ul>
    <li><strong>opus</strong> — better at matching vague descriptions to user intent</li>
    <li><strong>sonnet</strong> — good skill matching with clear descriptions</li>
    <li><strong>haiku</strong> — needs very explicit "use when:" clauses</li>
  </ul>

  <p>this is why skill descriptions matter so much — they need to work across all model tiers.</p>

  <h2>model versioning</h2>

  <p>models get updated over time. when you see <code>claude-sonnet-4-5-20250929</code>, that's:</p>

  <ul>
    <li><code>claude</code> — the model family</li>
    <li><code>sonnet-4-5</code> — the version (4.5)</li>
    <li><code>20250929</code> — the release date (sept 29, 2025)</li>
  </ul>

  <p>claude code automatically uses the latest stable version. you don't need to specify the date suffix.</p>

  <h2>extending with custom model integrations</h2>

  <p>claude code is designed for anthropic models (opus, sonnet, haiku). for other model providers:</p>

  <ul>
    <li><strong>openai, gemini, llama</strong> — not directly supported in claude code cli</li>
    <li><strong>custom agents</strong> — can be built with the claude agent sdk to wrap other models</li>
    <li><strong>mcp servers</strong> — can provide model-agnostic tool interfaces</li>
  </ul>

  <p>see <a href="/claude-1337/explanation/extensibility/">extensibility</a> for how to integrate other systems.</p>
</Base>
