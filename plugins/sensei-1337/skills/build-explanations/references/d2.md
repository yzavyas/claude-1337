# D2: When and How to Use It

D2 (Declarative Diagramming) for complex architecture diagrams when Mermaid isn't enough.

## THE Decision

**Default to Mermaid** (95% of cases). Only upgrade to D2 when:
- Complex architecture (50+ nodes) with poor Mermaid layout
- Precise positioning required for clarity
- Team willing to accept build step for better aesthetics
- Producing final diagrams for product documentation

**Trade-off**: D2 requires build step and pre-rendering. No native GitHub/GitLab rendering.

## When Mermaid Isn't Enough

| Issue with Mermaid | D2 Solution |
|-------------------|-------------|
| Auto-layout produces spaghetti | Multiple layout engines (dagre, ELK, TALA) |
| Limited styling control | CSS-like styling on elements |
| Poor positioning for complex diagrams | Better automatic positioning |
| Can't achieve specific layout | More control over grouping and hierarchy |

## D2 Strengths

**Natural nesting syntax**:
```d2
cloud: AWS {
  api: API Gateway {
    shape: rectangle
  }
  lambda: Lambda Functions {
    shape: cloud
  }
  db: RDS PostgreSQL {
    shape: cylinder
  }

  api -> lambda: invokes
  lambda -> db: queries
}
```

**Better layouts**: Dagre (fast), ELK (configurable), TALA (paid, best)

**Flexible styling**: Direct on elements, theme selection

**Systems focus**: Optimized for cloud architecture

## D2 vs Mermaid: Side-by-Side

### Mermaid
**Pros**:
- Zero build step (renders in markdown)
- Native GitHub/GitLab support
- 20+ diagram types (Gantt, timeline, mindmap)
- Instant preview loop
- Team adoption (everyone knows it)

**Cons**:
- Limited layout control
- Auto-layout can be messy
- Less styling flexibility
- Predefined diagram types only

### D2
**Pros**:
- Superior auto-layout
- Natural nesting syntax
- CSS-like styling
- Multiple layout engines
- Better for complex architecture

**Cons**:
- Build step required (CLI tool)
- No native GitHub/GitLab rendering
- Limited diagram variety (no Gantt/timeline)
- Must commit rendered images

## D2 Setup

**Installation**:
```bash
# macOS
brew install d2

# Linux
curl -fsSL https://d2lang.com/install.sh | sh

# Verify
d2 --version
```

**Basic usage**:
```bash
# Render to SVG
d2 architecture.d2 architecture.svg

# Specify layout engine
d2 --layout elk architecture.d2 architecture.svg

# Watch mode
d2 --watch architecture.d2 architecture.svg
```

## D2 Syntax Patterns

### Basic diagram
```d2
title: Microservices Architecture

api: API Gateway {
  style.fill: "#e3f2fd"
}
auth: Auth Service {
  style.fill: "#fff3e0"
}
db: PostgreSQL {
  shape: cylinder
  style.fill: "#f3e5f5"
}

api -> auth: authenticate
auth -> db: verify credentials
```

### Grouping
```d2
cloud: Production Environment {
  frontend: {
    web: React App
    mobile: Mobile App
  }
  backend: {
    api: API Server
    worker: Background Worker
  }
}
```

### Styling
```d2
service: My Service {
  shape: rectangle
  style.fill: "#2196f3"
  style.stroke: "#1976d2"
  style.font-color: white
  style.border-radius: 8
}
```

## Layout Engines

| Engine | When to Use | Trade-offs |
|--------|------------|------------|
| **dagre** (default) | Fast, simple diagrams | Unmaintained since 2018, non-optimal layouts |
| **elk** | Complex diagrams needing configuration | Can crash on large diagrams, Javaâ†’JS port |
| **tala** | Best layouts | Paid (Terrastruct) |

**Command**:
```bash
d2 --layout elk diagram.d2 output.svg
```

## Workflow Integration

### GitHub/GitLab workflow
1. Create `.d2` source files
2. Render to SVG in CI/CD or locally
3. Commit both source and rendered images
4. Reference SVG in markdown:
   ```markdown
   ![Architecture](./diagrams/architecture.svg)
   ```

### GitHub Actions example
```yaml
- name: Render D2 diagrams
  run: |
    curl -fsSL https://d2lang.com/install.sh | sh
    d2 diagrams/*.d2 diagrams/
```

## When NOT to Use D2

**Don't use D2 when**:
- Quick documentation (Mermaid's instant rendering wins)
- Need Gantt, timeline, or mindmap (D2 doesn't support)
- Team collaboration without build setup
- GitHub/GitLab native rendering is critical
- Diagram complexity doesn't justify build step

## Production Examples

**Quote from production users**:
> "Use D2 for architectural diagrams, and use Mermaid for everything else."

**Common pattern**:
- Mermaid: Sequence diagrams, flowcharts, ER diagrams, timelines
- D2: Cloud architecture, microservices topology, complex system diagrams

## Decision Checklist

Use D2 if ALL of these are true:
- [ ] Diagram has 50+ nodes or complex architecture
- [ ] Mermaid's auto-layout produces poor results
- [ ] Team can accept build step in workflow
- [ ] Native GitHub/GitLab rendering not required
- [ ] Need precise control over layout/styling

Otherwise, use Mermaid.

## D2 vs PlantUML

If considering D2, also consider PlantUML for:
- **C4 models**: C4-PlantUML is production-proven
- **Advanced UML**: Comprehensive diagram types
- **Sprites**: Standardized icon libraries

**Trade-off**: PlantUML requires Java + GraphViz (heavier than D2's Go binary)

**Verdict**: D2 for modern cloud architecture, PlantUML for formal C4 or advanced UML.

---

**Sources**: D2 official docs (d2lang.com), D2 vs Mermaid community discussions, production usage patterns
